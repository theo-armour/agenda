# viz3D

## To Do

* Ends on Red bars
* Rescale bars
* Replay all stats individually
* States to global map
* Other large jurisdictions: Brazil, India, Indonesia, Russia
* Prepare for Harald
* Rebuild oSome globe
* Improve Wikipedia workflow
* Twitter API
* Add to telephone messages
	* Random messages
	* In browser language
Notes to pop-up

## What we want to hear

* What you liked
* Suggested edits
	* Not helpful: "The colors need work"
	* Helpful: "The top one should be pink. The bottom one orange"

# Harald

* Zoom can pay. But why not Google hangouts?


Here is the list of topics from my previous email:
Next to practicing Pair-Programming on the tasks on your road map, I could think of

* Refactoring/clean up of your projects
* Setting up or improving continuous integration builds
* Setting up static code analysis and auto formatting
* Performance profiling and tuning
* unit/integration testing, or TDD

Questions

Pair programming is supposed to create programs with 15% fewer defects.

But with modern prettifiers and linters is the number of bugs - mistype vars, undeclared vars, missing semi-colons - is getting close to 0

## Possible objectives

* Creating a workflow for maintaining and re-imagining dozens of small projects
* Setting up more and better linting
	* Improving my usage of VS Code
* Designing tests for 3D
* Tricks for keeping to 60fps
* Taking care of the support, the marketing and the coding



## My guidelines


### Models

Perceive act judge

* Lewis model linear-active, multi-active, reactive
	( https://www.crossculture.com/the-lewis-model-dimensions-of-behaviour/
* Problems - assumptions - approach
	* https://www.freecodecamp.org/news/how-to-organize-your-thoughts-on-the-whiteboard-and-crush-your-technical-interview-b668de4e6941/
* Three types of activity - twitter


### Knowledge on a globe - categories as Voronoi objects spread around the globe

* infinitely extendible - can't see what is next on the back side - so you can have anything there
* History of dividing globe - hexagons, mercator etc
* Draw on surface
* categories by radius
* What happens inside the Globe?
* 3D text linked to Pop-ups
* Create a use for the Pacific Ocean

### Category theory

### Perceive Act Judge

### Map is not the territory


### "Don't make me change" / Functional suitability?

* All versions of a Spider web page - present and past - are runnable and viewable in your browser
	* Why: Refute Clarke's third law: to remind that software is not magic but the result of hard work, perseverance and care
	* Why: Debug visual appearance: to be able to see and compare before and after
	* Why: Mitigate Change Aversion - allow a user of any version to stay with that version

### Don't make me think / Usability?

* Runs now
* Usage is self evident.  a web page it should be self evident. Obvious. self explanatory.
* Everybody knows the Globe



### Trunk Driven Development



### Calendar Versioning


### three.js performance profiling and improvement

* Loading large amounts of data
* Creating many 3D objects
* Enabling user interaction with hundreds of obects
* Keeps the Globe spining without too much jitter]
* Maintain a high rate of framers per second - 60 gps being ideal
* Make it all happn on computer, tablet or phone

### Tool independent / Portability?

* All code can be generated, run and tested using on Windows Notepad as your IDS running offline
	* Why: to make every thing available to the new user
	* Why: to be independent of any particular set of tools
	* Why: to be available to any tools you might want to use
	* Code runs locally without a server, without compiling. Hit enter, it works.


### Reuse code everywhere


### Where is the source code for this function




### Move fast. Build the demo today. Solve the problem. Agile / Performance efficiency

* Think SEO - need frequent updates. topical. exciting

* All code is plain vanilla JavaScript with few if any dependencies
	* Why: want to spend time thinking about physics and math - the project at hand- and not thinking about the code
* All output has aspects of beauty


Problem: learning to code is an effort. Solution: Learning and inciting riot

* All code is designed for easy reading, very simple algorithms with a pleasing appearance
	* Why: when to code is a fast read you don't need documents
	* Why: good readily available source code is its on documentation
	* Understandable to a listener when read aloud
	* Pedagogical playground. cookbook code. Many small scripts. Seriously easy.
	* Like a pseudo-



### Remixing Plain Vanilla JavaScript

* All code can be read and used by beginners AND by Rust and by Angular developers
	Why: enabling re-mixing by others is a priority
* Design for the future. Build for the past


### Problem Solving

Pattern Language problem solving

### No compiling

* It just runs
* It just works


### Style Guides &  Docs

* Follow the leader
* Read me driven development


### Computer, tablet & Phone

* Mobile first

### Static hosting

* GitHub pages rules
* CORS


### Metrics

* Background
	* Peter Drucker: What gets measured gets improved
	* Peter Drucker: You can’t manage what you don’t measure.
* How are we to know if we are doing the right things? Improving?
Are there metrics we can adapt

### Decide what we are doing

* Background
	* Peter Drucker: There is nothing so useless as doing efficiently that which should not be done at all.
	* Peter Drucker: Doing the right thing is more important than doing the thing right
	* Peter Drucker: Do not believe that it is very much of an advance to do the unnecessary three times as fast.
	* Peter Drucker: if you want something new, you have to stop doing something old.



### DRY


### Abstraction

Swanson: 2. It is easier to get into something than it is to get out of it.


***

## Not forgetting

I am a designer, not a programmer. Mostly I build what I call "demos". These are small proof of concept efforts. Once you have run the demo and seen the code, you cannot "un-see". What I hope is that you - or whoever -  take what I build and remix it and embed the ideas in the projects you are working on.

Completing the project is a higher priority than following an elegant process




## Links of interest


Users hate change

* [Users Don’t Hate Change. They Hate Our Design Choices.]( https://articles.uie.com/users-dont-hate-change-they-hate-our-design-choices/ )
* ['Users hate change']( https://gist.github.com/sleepyfox/a4d311ffcdc4fd908ec97d1c245e57dc )
	* https://news.ycombinator.com/item?id=20533026
* [Change Aversion And The Conflicted User]( https://usabilitygeek.com/change-aversion-conflicted-user/ )
* Workflow: https://xkcd.com/1172/
* [Users don’t hate change. They hate you.]( https://medium.com/@cwodtke/users-dont-hate-change-they-hate-you-461772fbcac7 )
* [Change aversion: why users hate what you launched (and what to do about it)]( https://library.gv.com/change-aversion-why-users-hate-what-you-launched-and-what-to-do-about-it-2fb94ce65766 )


 technology is indistinguishable from magic.

* [Clarke's three laws]( https://en.wikipedia.org/wiki/Clarke%27s_three_laws )


Don't make me think

The book's premise is that a good software program or web site should let users accomplish their intended tasks as easily and directly as possible.

It means that as far as is humanly possible, when I look at a web page it should be self evident. Obvious. self explanatory. I should be able to "get it" - what it is and how to use it - without expanding any effort thinking about it.

* https://www.amazon.com/Dont-Make-Me-Think-Usability/dp/0321344758
* https://www.amazon.com/Dont-Make-Think-Revisited-Usability/dp/0321965515
* https://en.wikipedia.org/wiki/Don%27t_Make_Me_Think


Tool independent

* https://en.wikipedia.org/wiki/Pseudocode
* https://en.wikipedia.org/wiki/Cross-platform_software

Coding Standards

* https://github.com/johngrogg/coding-standards/blob/master/code-review.md